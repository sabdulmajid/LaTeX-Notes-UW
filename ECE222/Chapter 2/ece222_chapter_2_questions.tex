\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=0.57in]{geometry}

\begin{document}

\section*{Chapter 2 Questions - Assignment Questions for Week 2}

\begin{enumerate}
    \item[\textbf{2.1}] \textbf{<§2.2>} For the following C statement, write the corresponding RISC-V 
    assembly code. Assume that the C variables \texttt{f}, \texttt{g}, and \texttt{h}, have already been placed in registers \texttt{x5}, \texttt{x6}, and \texttt{x7} respectively. Use a minimal number of RISC-V assembly 
    instructions.
    \begin{verbatim}
    f = g + (h - 5);
    \end{verbatim}

    \item[\textbf{2.2}] \textbf{<§2.2>} Write a single C statement that corresponds to the two RISC-V 
    assembly instructions below.
    \begin{verbatim}
    add f, g, h
    add f, i, f
    \end{verbatim}

    \item[\textbf{2.3}] \textbf{<§§2.2, 2.3>} For the following C statement, write the corresponding 
    RISC-V assembly code. Assume that the variables \texttt{f}, \texttt{g}, \texttt{h}, \texttt{i}, and \texttt{j} are assigned to registers \texttt{x5}, \texttt{x6}, \texttt{x7}, \texttt{x28}, and \texttt{x29}, respectively. Assume that the base address of the arrays \texttt{A} and \texttt{B} are in registers \texttt{x10} and \texttt{x11}, respectively.
    \begin{verbatim}
    B[8] = A[i - j];
    \end{verbatim}

    \item[\textbf{2.4}] \textbf{<§§2.2, 2.3>} For the RISC-V assembly instructions below, what is the 
    corresponding C statement? Assume that the variables \texttt{f}, \texttt{g}, \texttt{h}, \texttt{i}, and \texttt{j} are assigned to registers \texttt{x5}, \texttt{x6}, \texttt{x7}, \texttt{x28}, and \texttt{x29}, respectively. Assume that the base address of the arrays \texttt{A} and \texttt{B} are in registers \texttt{x10} and \texttt{x11}, respectively.
    \begin{verbatim}
    slli x30, x5, 3 // x30 = f*8
    add x30, x10, x30 // x30 = &A[f]
    slli x31, x6, 3 // x31 = g*8
    add x31, x11, x31 // x31 = &B[g]
    ld x5, 0(x30) // f = A[f]
    addi x12, x30, 8
    ld x30, 0(x12)
    add x30, x30, x5
    sd x30, 0(x31)
    \end{verbatim}

    \item[\textbf{2.5}] \textbf{<§2.3>} Show how the value \texttt{0xabcdef12} would be arranged in memory of a little-endian and a big-endian machine. Assume the data is stored starting at 
    address 0 and that the word size is 4 bytes.

    \item[\textbf{2.7}] \textbf{<§§2.2, 2.3>} Translate the following C code to RISC-V. Assume that the 
    variables \texttt{f}, \texttt{g}, \texttt{h}, \texttt{i}, and \texttt{j} are assigned to registers \texttt{x5}, \texttt{x6}, \texttt{x7}, \texttt{x28}, and \texttt{x29}, 
    respectively. Assume that the base address of the arrays \texttt{A} and \texttt{B} are in registers \texttt{x10}
    and \texttt{x11}, respectively. Assume that the elements of the arrays \texttt{A} and \texttt{B} are 8-byte 
    words:
    \begin{verbatim}
    B[8] = A[i] + A[j];
    \end{verbatim}
    \pagebreak
    \item[\textbf{2.10}] \textbf{<§2.4>} Assume that registers \texttt{x5} and \texttt{x6} hold the values \texttt{0x8000000000000000} and \texttt{0xD000000000000000}.
    \begin{enumerate}
        \item[\textbf{2.10.1}] What is the value of \texttt{x30} for the following assembly code?
        \begin{verbatim}
        add x30, x5, x6
        \end{verbatim}

        \item[\textbf{2.10.2}] Is the result in \texttt{x30} the desired result, or has there been 
        overflow?

        \item[\textbf{2.10.3}] For the contents of registers \texttt{x5} and \texttt{x6} as specified above, 
        what is the value of \texttt{x30} for the following assembly code?
        \begin{verbatim}
        sub x30, x5, x6
        \end{verbatim}

        \item[\textbf{2.10.4}] Is the result in \texttt{x30} the desired result, or has there been 
        overflow?

        \item[\textbf{2.10.5}] For the contents of registers \texttt{x5} and \texttt{x6} as specified above, 
        what is the value of \texttt{x30} for the following assembly code?
        \begin{verbatim}
        add x30, x5, x6
        add x30, x30, x5
        \end{verbatim}

        \item[\textbf{2.10.6}] Is the result in \texttt{x30} the desired result, or has there been 
        overflow?
    \end{enumerate}

    \item[\textbf{2.12}] \textbf{<§§2.2, 2.5>} Provide the instruction type and assembly language 
    instruction for the following binary value (Hint: Figure 2.20 may be helpful): 
    \begin{verbatim}
    0000 0000 0001 0000 1000 0000 1011 0011 (two)
    \end{verbatim}
    
    \item[\textbf{2.13}] \textbf{<§§2.2, 2.5>} Provide the instruction type and hexadecimal representation of the following instruction:
    \begin{verbatim}
    sd x5, 32(x30)
    \end{verbatim}

    \item[\textbf{2.16}] \textbf{<§§2.5, 2.8, 2.10>} Assume that we would like to expand the RISC-V register file to 128 registers 
    and expand the instruction set to contain four times as many instructions.
    
    \begin{enumerate}
        \item[\textbf{2.16.1}] How would this affect the size of each of the bit fields in the 
        R-type instructions?
        
        \item[\textbf{2.16.2}] How would this affect the size of each of the bit fields in the 
        I-type instructions?
        
        \item[\textbf{2.16.3}] How could each of the two proposed changes 
        decrease the size of a RISC-V assembly program? On the other hand, how could 
        the proposed change increase the size of an RISC-V assembly program?
    \end{enumerate}

    \item[\textbf{2.22}] \textbf{<§2.10>} Suppose the program counter (PC) is set to 0x20000000.
    
    \begin{enumerate}
        \item[\textbf{2.22.1}] What range of addresses can be reached using the RISC-V 
        jump-and-link (jal) instruction? (In other words, what is the set of possible values 
        for the PC after the jump instruction executes?)
        
        \item[\textbf{2.22.2}] What range of addresses can be reached using the RISC-V 
        branch if equal (beq) instruction? (In other words, what is the set of possible values 
        for the PC after the branch instruction executes?)
    \end{enumerate}

    \item[\textbf{2.23}] \textbf{<§2.7, 2.10>} Consider a proposed new instruction named \texttt{rpt}. This instruction combines 
    a loop’s condition check and counter decrement into a single instruction. For 
    example \texttt{rpt x29}, loop would do the following:
    \begin{verbatim}
    if (x29 > 0) {
    x29 = x29 -1;
    goto loop
    }
    \end{verbatim}
    
    \begin{enumerate}
        \item[\textbf{2.23.1}] If this instruction were to be added to the RISC-V 
        instruction set, what is the most appropriate instruction format?
        
        \item[\textbf{2.23.2}] What is the shortest sequence of RISC-V instructions that 
        performs the same operation?
    \end{enumerate}
    
    \item[\textbf{2.27}] \textbf{<§2.7>} Translate the following loop into C. Assume that the C-level 
    integer i is held in register \texttt{x5}, \texttt{x6} holds the C-level integer called result, and 
    \texttt{x10} holds the base address of the integer MemArray.
    \begin{verbatim}
    addi x6, x0, 0
    addi x29, x0, 100
    LOOP: ld x7, 0(x10)
    add x5, x5, x7
    addi x10, x10, 8
    addi x6, x6, 1
    blt x6, x29, LOOP
    \end{verbatim}

    \item[\textbf{2.28}] \textbf{<§2.7>} Rewrite the loop from Exercise 2.27 to reduce the number of 
    RISC-V instructions executed. Hint: Notice that variable i is used only for loop 
    control.
    
    \item[\textbf{2.36}] \textbf{<§2.10>} Write the RISC-V assembly code that creates the 64-bit constant 
    0x1122334455667788two and stores that value to register x10.
    
    \item[\textbf{2.40}] \textbf{<§§1.6, 2.13>} Assume that for a given program 70\% of the executed instructions are arithmetic, 10\% are load/store, and 20\% are branch.
    
    \begin{enumerate}
        \item[\textbf{2.40.1}] Given this instruction mix and the assumption that an 
        arithmetic instruction requires two cycles, a load/store instruction takes six cycles, 
        and a branch instruction takes three cycles, find the average CPI.
        
        \item[\textbf{2.40.2}] For a 25\% improvement in performance, how many 
        cycles, on average, may an arithmetic instruction take if load/store and branch 
        instructions are not improved at all?
        
        \item[\textbf{2.40.3}] For a 50\% improvement in performance, how many 
        cycles, on average, may an arithmetic instruction take if load/store and branch 
        instructions are not improved at all?
    \end{enumerate}

\end{enumerate}

\end{document}
